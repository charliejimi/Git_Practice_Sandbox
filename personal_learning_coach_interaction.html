<!DOCTYPE html>
<html lang="zh-TW">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>å½±ç‰‡å­¸ç¿’å°åŠ©æ‰‹ - è­‰æ“šåˆ†æèˆ‡ N+1 æ¨è«–ç‰ˆ</title>
  <!-- è¼‰å…¥ Tailwind CSS CDN -->
  <script src="https://cdn.tailwindcss.com"></script>
  <!-- è¼‰å…¥ React, ReactDOM, Babel CDN -->
  <script src="https://unpkg.com/react@18/umd/react.development.js"></script>
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
  <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
  <!-- è¼‰å…¥ PDF.js ä»¥æ”¯æ´ PDF è§£æ -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js"></script>

  <!-- Tailwind è¨­å®š -->
  <script>
    tailwind.config = {
      theme: {
        extend: {
          fontFamily: {
            sans: ['Inter', 'Noto Sans TC', 'sans-serif'],
          },
        }
      }
    }
  </script>
  <style>
    /* ç¢ºä¿å…¨åŸŸä½¿ç”¨ Inter å’Œ Noto Sans TC ä»¥æ”¯æ´ä¸­æ–‡ */
    body {
      font-family: 'Inter', 'Noto Sans TC', 'sans-serif';
    }

    /* éš±è—æ–‡ä»¶è¼¸å…¥æ¬„çš„é è¨­æ¨£å¼ï¼Œä½¿å…¶æ›´ç¾è§€ */
    input[type="file"] {
      border: none;
      padding: 0;
    }

    /* é å…ˆæ ¼å¼åŒ–å€å¡Šï¼Œç”¨æ–¼ AI çš„çµæ§‹åŒ–å›è¦† */
    .ai-response-block pre {
      white-space: pre-wrap;
      word-break: break-word;
      font-family: inherit;
      /* è®“ pre ç¹¼æ‰¿ sans-serif */
      background-color: #f3f4f6;
      padding: 0.5rem;
      border-radius: 0.375rem;
      margin-top: 0.5rem;
    }

    /* ç¾åŒ–æŒ‰éˆ•çš„åœ“è§’å’Œé™°å½± */
    .btn-fancy {
      border-radius: 0.5rem;
      box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
      transition: all 0.2s ease-in-out;
    }

    .btn-fancy:hover {
      box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05);
      transform: translateY(-1px);
    }
  </style>
</head>

<body class="bg-gray-100 antialiased">
  <div id="root">
    <!-- React App å°‡åœ¨æ­¤è™•æ¸²æŸ“ -->
  </div>

  <!-- æ ¸å¿ƒæ‡‰ç”¨ç¨‹å¼é‚è¼¯ (ä½¿ç”¨ Babel è™•ç† JSX) -->
  <script type="text/babel">
    // è¨­å®š PDF.js worker
    pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js';

    // ç‚ºäº†åœ¨ CDN ç’°å¢ƒä¸­é‹è¡Œï¼Œæˆ‘å€‘å¾å…¨åŸŸè®Šæ•¸ä¸­è§£æ§‹ React é‰¤å­
    const { useState, useCallback, useEffect } = React;

    // -----------------------------------------------------------------------------
    // è¼”åŠ©å‡½å¼ (Helper Functions)
    // -----------------------------------------------------------------------------

    /**
     * å°‡ File ç‰©ä»¶è½‰æ›ç‚º Base64 å­—ä¸² (ç”¨æ–¼åœ–ç‰‡)
     */
    const toBase64 = (file) => new Promise((resolve, reject) => {
      const reader = new FileReader();
      reader.readAsDataURL(file);
      reader.onload = () => resolve(reader.result);
      reader.onerror = error => reject(error);
    });

    /**
     * è®€å–æ–‡å­—æª”æ¡ˆ (.txt)
     */
    const readTextFile = (file) => new Promise((resolve, reject) => {
      const reader = new FileReader();
      reader.onload = (e) => resolve(e.target.result);
      reader.onerror = (e) => reject(e);
      reader.readAsText(file);
    });

    /**
     * è®€å– PDF æª”æ¡ˆä¸¦æå–ç´”æ–‡å­—
     */
    const readPdfFile = async (file) => {
      const arrayBuffer = await file.arrayBuffer();
      const pdf = await pdfjsLib.getDocument({ data: arrayBuffer }).promise;
      let fullText = "";
      
      for (let i = 1; i <= pdf.numPages; i++) {
        const page = await pdf.getPage(i);
        const textContent = await page.getTextContent();
        const pageText = textContent.items.map(item => item.str).join(" ");
        fullText += `[Page ${i}] ${pageText}\n`;
      }
      return fullText;
    };

    /**
     * å…·æœ‰æŒ‡æ•¸é€€é¿é‡è©¦æ©Ÿåˆ¶çš„ fetch å‡½å¼
     */
    async function fetchWithRetry(url, options, retries = 3) {
      let attempt = 0;
      while (attempt < retries) {
        try {
          const response = await fetch(url, options);
          if (!response.ok) {
            const errorBody = await response.text();
            throw new Error(`HTTP éŒ¯èª¤! ç‹€æ…‹: ${response.status}. éŒ¯èª¤è©³æƒ…: ${errorBody.substring(0, 100)}...`);
          }
          // æª¢æŸ¥æ˜¯å¦ç‚º TTS è«‹æ±‚ï¼ŒTTS è«‹æ±‚ç›´æ¥è¿”å› Response ç‰©ä»¶ä»¥ä¾¿å¾ŒçºŒè™•ç†
          if (url.includes("gemini-2.5-flash-preview-tts")) {
            return response;
          }
          return await response.json();
        } catch (error) {
          console.warn(`ç¬¬ ${attempt + 1} æ¬¡ API å‘¼å«å¤±æ•—: ${error.message}`);
          attempt++;
          if (attempt >= retries) {
            throw error; // é‡è©¦æ¬¡æ•¸ç”¨ç›¡ï¼Œæ‹‹å‡ºéŒ¯èª¤
          }
          const delay = Math.pow(2, attempt) * 1000 + Math.random() * 1000;
          await new Promise(resolve => setTimeout(resolve, delay));
        }
      }
    }

    // -----------------------------------------------------------------------------
    // ä¸»æ‡‰ç”¨ç¨‹å¼çµ„ä»¶ (Main App Component)
    // -----------------------------------------------------------------------------

    /**
     * ä¸»æ‡‰ç”¨ç¨‹å¼çµ„ä»¶
     */
    function App() {
      // --- åŸºæœ¬è³‡æ–™ç‹€æ…‹ ---
      const [problemStatement, setProblemStatement] = useState(''); // æ¬²è§£æ±ºçš„å•é¡Œæˆ–ç›®æ¨™
      const [transcript, setTranscript] = useState(''); // é€å­—ç¨¿æ–‡å­—
      const [images, setImages] = useState([]); // { name: string, base64: string }
      
      // --- N+1 è£œå……è³‡æ–™ç‹€æ…‹ ---
      const [suppText, setSuppText] = useState(''); // ä½¿ç”¨è€…ç›´æ¥è²¼ä¸Šçš„è£œå……æ–‡å­—
      const [suppFiles, setSuppFiles] = useState([]); // [{ type: 'image'|'text', name: string, content: string(base64 or text) }]

      // --- äº’å‹•èˆ‡ç³»çµ±ç‹€æ…‹ ---
      const [chatHistory, setChatHistory] = useState([]); 
      const [userQuery, setUserQuery] = useState(''); 
      const [isLoading, setIsLoading] = useState(false); 
      const [categorization, setCategorization] = useState(''); 
      const [importedSummary, setImportedSummary] = useState(''); 
      const [importedFileName, setImportedFileName] = useState(''); 

      const [quizContent, setQuizContent] = useState(''); 
      const [isQuizLoading, setIsQuizLoading] = useState(false); 
      const [isSidebarOpen, setIsSidebarOpen] = useState(true); 


      // !!! é‡è¦: è«‹åœ¨é€™è£¡è²¼ä¸Šæ‚¨çš„ Google AI Studio API é‡‘é‘° !!!
      const apiKey = "AIzaSyDgEJp5PR_XH2mAKQd_FsCDOABtLPkI9qU";

      /**
       * è™•ç†åŸºæœ¬åœ–ç‰‡ä¸Šå‚³ (åŸå§‹è³‡æ–™)
       */
      const handleImageUpload = async (e) => {
        if (e.target.files) {
          setIsLoading(true);
          const fileList = Array.from(e.target.files);
          const newImages = [];
          for (const file of fileList) {
            if (file.type.startsWith('image/')) {
              try {
                const base64 = await toBase64(file);
                newImages.push({ name: file.name, base64 });
              } catch (error) {
                console.error("è™•ç†åœ–ç‰‡å¤±æ•—:", error);
              }
            }
          }
          setImages(prev => [...prev, ...newImages]);
          setIsLoading(false);
        }
      };

      const removeImage = (index) => {
        setImages(prev => prev.filter((_, i) => i !== index));
      };

      /**
       * è™•ç† N+1 è£œå……è³‡æ–™ä¸Šå‚³ (æ”¯æ´ PDF, TXT, åœ–ç‰‡)
       */
      const handleSuppFileUpload = async (e) => {
        if (!e.target.files) return;
        setIsLoading(true);
        const fileList = Array.from(e.target.files);
        const newFiles = [];

        for (const file of fileList) {
            try {
                let fileData = null;
                if (file.type === 'application/pdf') {
                    const text = await readPdfFile(file);
                    fileData = { type: 'text', name: file.name, content: text };
                } else if (file.type === 'text/plain') {
                    const text = await readTextFile(file);
                    fileData = { type: 'text', name: file.name, content: text };
                } else if (file.type.startsWith('image/')) {
                    const base64 = await toBase64(file);
                    fileData = { type: 'image', name: file.name, content: base64 };
                } else {
                    alert(`ä¸æ”¯æ´çš„æª”æ¡ˆæ ¼å¼: ${file.name}ã€‚åƒ…æ”¯æ´ PDF, TXT, JPG, PNGã€‚`);
                    continue;
                }
                if(fileData) newFiles.push(fileData);
            } catch (error) {
                console.error(`è™•ç†æª”æ¡ˆ ${file.name} å¤±æ•—:`, error);
                alert(`è®€å– ${file.name} å¤±æ•—ï¼Œè«‹ç¢ºèªæª”æ¡ˆæ˜¯å¦ææ¯€ã€‚`);
            }
        }

        setSuppFiles(prev => [...prev, ...newFiles]);
        setIsLoading(false);
        // æ¸…ç©º input ä»¥ä¾¿é‡è¤‡ä¸Šå‚³
        e.target.value = null;
      };

      const removeSuppFile = (index) => {
        setSuppFiles(prev => prev.filter((_, i) => i !== index));
      };

      /**
       * è™•ç†æª”æ¡ˆåŒ¯å…¥ (ä¸Šæ¬¡çš„ç¸½çµçµæœ)
       */
      const handleImport = async (e) => {
        if (!e.target.files || e.target.files.length === 0) return;
        setIsLoading(true);
        const file = e.target.files[0];
        const reader = new FileReader();

        reader.onload = async (event) => {
          try {
            const content = event.target.result;
            setImportedSummary(content);
            setImportedFileName(file.name);
            e.target.value = null;
            alert('åŒ¯å…¥æˆåŠŸï¼šä¸Šæ¬¡çš„ç¸½çµå…§å®¹å·²è¼‰å…¥ï¼Œå°‡åœ¨ä¸‹æ¬¡æ­¸ç´æ™‚é€²è¡Œå½™æ•´ã€‚');
          } catch (error) {
            console.error("è™•ç†åŒ¯å…¥æª”æ¡ˆå¤±æ•—:", error);
            alert("åŒ¯å…¥å¤±æ•—ï¼šæª”æ¡ˆæ ¼å¼å¯èƒ½ä¸æ­£ç¢ºæˆ–ç„¡æ³•è®€å–ã€‚");
          } finally {
            setIsLoading(false);
          }
        };
        reader.readAsText(file);
      };

      /**
       * è™•ç†ç¸½çµçµæœåŒ¯å‡º
       */
      const handleExport = () => {
        if (!categorization) {
          alert("è«‹å…ˆç”¢ç”Ÿç¸½çµçµæœæ‰èƒ½åŒ¯å‡ºï¼");
          return;
        }
        const filename = `Summary_${new Date().toISOString().slice(0, 10)}.md`;
        const blob = new Blob([categorization], { type: 'text/markdown;charset=utf-8' });
        const url = URL.createObjectURL(blob);
        const link = document.createElement('a');
        link.href = url;
        link.download = filename;
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
        URL.revokeObjectURL(url);
        alert(`ç¸½çµçµæœå·²åŒ¯å‡ºç‚º ${filename}`);
      };


      /**
       * å‘¼å« Gemini API
       */
      const callGeminiAPI = async (contents, systemInstruction, model = 'gemini-2.5-flash-preview-09-2025') => {
        if (!apiKey) {
          setIsLoading(false);
          return "éŒ¯èª¤ï¼šè«‹å…ˆåœ¨ç¨‹å¼ç¢¼ä¸­è²¼ä¸Šæ‚¨çš„ API é‡‘é‘°ï¼";
        }
        setIsLoading(true);
        const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/${model}:generateContent?key=${apiKey}`;

        const payload = {
          contents: contents,
          systemInstruction: {
            parts: [{ text: systemInstruction }]
          }
        };

        try {
          const result = await fetchWithRetry(apiUrl, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(payload)
          });

          const text = result.candidates?.[0]?.content?.parts?.[0]?.text;
          if (text) {
            return text;
          } else {
            console.error("API å›æ‡‰ä¸­æ‰¾ä¸åˆ°æ–‡å­—:", result);
            return "æŠ±æ­‰ï¼Œæˆ‘ç„¡æ³•è™•ç†æ‚¨çš„è«‹æ±‚ã€‚è«‹æª¢æŸ¥ API å›æ‡‰çµæ§‹æ˜¯å¦æ­£ç¢ºã€‚";
          }
        } catch (error) {
          console.error("API å‘¼å«å¤±æ•—:", error);
          return `ç™¼ç”ŸéŒ¯èª¤ï¼Œå¯èƒ½æ˜¯ API é‡‘é‘°ç„¡æ•ˆæˆ–è«‹æ±‚ Payload éå¤§ (åœ–ç‰‡éå¤š)ã€‚éŒ¯èª¤è¨Šæ¯ï¼š${error.message}`;
        } finally {
          setIsLoading(false);
        }
      };

      // [æ¸¬é©—é¡ŒåŠŸèƒ½]
      const handleGenerateQuestions = async () => {
        if (!categorization || isQuizLoading) return;

        setQuizContent('');
        setIsQuizLoading(true);

        const systemInstruction = `
                ä½ æ˜¯ä¸€ä½æ¸¬é©—è¨­è¨ˆå°ˆå®¶ã€‚
                ä½ çš„ä»»å‹™æ˜¯æ ¹æ“šä½¿ç”¨è€…æä¾›çš„æœ€çµ‚ç¸½çµå…§å®¹ï¼Œç”Ÿæˆ 3-5 é“æ¸¬é©—é¡Œï¼Œä»¥å¹«åŠ©ä½¿ç”¨è€…æª¢è¦–ä»–å€‘å°ç¸½çµä¸­ä¸»è¦æ¦‚å¿µçš„æŒæ¡ç¨‹åº¦ã€‚
                è«‹åš´æ ¼éµå¾ªä»¥ä¸‹è¦æ±‚ï¼š
                1. åƒ…ä½¿ç”¨ç¸½çµå…§å®¹ä½œç‚ºå‡ºé¡Œä¾æ“šã€‚
                2. é¡Œç›®é¡å‹å¯ä»¥æ˜¯é¸æ“‡é¡Œã€æ˜¯éé¡Œæˆ–ç°¡ç­”é¡Œï¼Œå‹™å¿…æä¾›æ­£ç¢ºç­”æ¡ˆã€‚
                3. å¿…é ˆä½¿ç”¨ç¹é«”ä¸­æ–‡ã€‚
                è¼¸å‡ºæ ¼å¼ï¼šMarkdownã€‚
            `;

        const contents = [{
          role: "user",
          parts: [{ text: `è«‹æ ¹æ“šä»¥ä¸‹ç¸½çµå…§å®¹ç”Ÿæˆæ¸¬é©—é¡Œï¼š\n\n${categorization}` }]
        }];

        try {
          const quizText = await callGeminiAPI(contents, systemInstruction);
          setQuizContent(quizText);
        } catch (error) {
          console.error("ç”Ÿæˆæ¸¬é©—é¡Œå¤±æ•—:", error);
          setQuizContent("æŠ±æ­‰ï¼Œç”Ÿæˆæ¸¬é©—é¡Œæ™‚ç™¼ç”ŸéŒ¯èª¤ã€‚");
        } finally {
          setIsQuizLoading(false);
        }
      };


      const hasPreviousSummary = categorization && categorization.trim() !== '';

      /**
       * è™•ç†ä½¿ç”¨è€…æå• (è­‰æ“šåˆ†æå¼ + N+1 æ¨è«–)
       */
      const handleQuerySubmit = async (e) => {
        e.preventDefault();
        if (!userQuery.trim() || isLoading) return;
        setQuizContent('');

        const newUserMessage = { role: 'user', text: userQuery };
        setChatHistory(prev => [...prev, newUserMessage]);
        const currentQuery = userQuery;
        setUserQuery('');

        // --- æº–å‚™ System Prompt ---
        const inferenceInstructions = `
          **ç‰¹åˆ¥æŒ‡ä»¤ï¼šN+1 / N+2 æ¨è«–æ©Ÿåˆ¶**
          ç•¶ä½¿ç”¨è€…æ˜ç¢ºè¦æ±‚ã€Œæ ¹æ“šè³‡æ–™æ¨è«–ã€ã€ã€Œæ¨æ¸¬ã€ã€ã€Œå¦‚æœ...æœƒæ€æ¨£ã€æˆ–è©¢å•ç›®å‰è³‡æ–™ç„¡æ³•ç›´æ¥å›ç­”çš„å•é¡Œæ™‚ï¼Œè«‹å‹™å¿…ä¾ç…§ä»¥ä¸‹ä¸‰å€‹çµæ§‹é€²è¡Œå›æ‡‰ï¼š
          
          ### 1. ç¾ç‹€ç¢ºèª (N)
          - **å·²çŸ¥äº‹å¯¦ï¼š** æ˜ç¢ºæŒ‡å‡ºç›®å‰æä¾›çš„è³‡æ–™ (é€å­—ç¨¿/æˆªåœ–) ä¸­ç¢ºèªäº†ä»€éº¼äº‹å¯¦ã€‚
          - **ç¼ºå£èªªæ˜ï¼š** èªªæ˜ç‚ºä»€éº¼é€™äº›è³‡æ–™ä¸è¶³ä»¥ç›´æ¥å›ç­”å•é¡Œã€‚
          
          ### 2. æ¨ç†éç¨‹ (N+1 / N+2)
          - **é‚è¼¯æ¨æ¼”ï¼š** åŸºæ–¼å·²çŸ¥äº‹å¯¦ (N)ï¼Œé€²è¡Œåˆç†çš„é‚è¼¯å»¶ä¼¸ã€‚
          - **æ¢åˆ—å¼å±•ç¤ºï¼š** **å¿…é ˆä½¿ç”¨æ¢åˆ—å¼æ¸…å–®** ä¸€æ­¥æ­¥å±•ç¤ºæ¨ç†é‚è¼¯ (ä¾‹å¦‚ï¼š1. å› ç‚ºäº‹å¯¦ A... 2. é€šå¸¸æƒ…æ³ä¸‹ B æ„å‘³è‘— C... 3. æ•…æ¨æ¸¬ D)ã€‚
          - æ¸…æ¥šå€åˆ†å“ªäº›æ˜¯ã€Œè­‰æ“šã€å“ªäº›æ˜¯ã€Œæ¨è«–ã€ã€‚
          
          ### 3. æå‡æº–ç¢ºåº¦çš„è³‡æ–™éœ€æ±‚ (é—œéµ)
          - **éœ€è¦çš„è³‡æ–™æ–¹å‘ï¼š** ç‚ºäº†è®“ä¸Šè¿°æ¨è«– (N+1) è®Šç‚ºç¢ºå®šçš„äº‹å¯¦ (N)ï¼Œç³»çµ±**å¿…é ˆè¦æ±‚**ä½¿ç”¨è€…è£œå……ç‰¹å®šæ–¹å‘çš„è³‡æ–™ã€‚
          - **å…·é«”å»ºè­°ï¼š** è«‹æ˜ç¢ºå‘Šè¨´ä½¿ç”¨è€…ã€Œå“ªå€‹æ–¹å‘ã€çš„è³‡æ–™æœ‰å¹«åŠ©ã€‚
            - ä¾‹å¦‚ï¼šã€Œç‚ºäº†è­‰å¯¦é€™é»ï¼Œè«‹æä¾› [è¨­å®šé¸å–®] çš„æˆªåœ–ã€æˆ–ã€Œè«‹ç¢ºèªé€å­—ç¨¿ä¸­æ˜¯å¦æœ‰é—œæ–¼ [XX åŠŸèƒ½] çš„è¨è«–ã€ã€‚
          - **ç›®çš„èªªæ˜ï¼š** è§£é‡‹é€™ä»½æ–°è³‡æ–™å°‡å¦‚ä½•é©—è­‰æ¨è«–çš„æ­£ç¢ºæ€§ã€‚

          **æ³¨æ„ï¼š** å¦‚æœä½¿ç”¨è€…å·²ç¶“åœ¨ã€Œè£œå……é©—è­‰è³‡æ–™ã€å€å¡Šæä¾›äº†è³‡æ–™ï¼Œè«‹å„ªå…ˆåƒè€ƒè©²è³‡æ–™ä¾†é©—è­‰ä¹‹å‰çš„æ¨è«–ï¼Œä¸¦åœ¨å›ç­”ä¸­æ˜ç¢ºæŒ‡å‡ºã€Œæ ¹æ“šæ‚¨æ–°æä¾›çš„è£œå……è³‡æ–™...ã€ã€‚
        `;

        let systemPrompt;
        let baseInstructions = hasPreviousSummary 
            ? `ä½ æ˜¯ä¸€ä½è­‰æ“šå‹å­¸ç¿’åˆ†ææ•™ç·´ã€‚ä½ å…ˆå‰å·²ç¶“å¹«åŠ©ä½¿ç”¨è€…æ­¸ç´å‡ºä¸€å€‹ç¸½çµã€‚ç¾åœ¨ï¼Œä½¿ç”¨è€…æ­£åœ¨å°è©²ç¸½çµæˆ–åŸå§‹è³‡æ–™æå‡ºã€Œå¾ŒçºŒè¿½å•ã€ã€‚`
            : `ä½ æ˜¯ä¸€ä½è­‰æ“šå‹å­¸ç¿’åˆ†ææ•™ç·´ã€‚ä½ çš„ä¸»è¦ç›®æ¨™æ˜¯å¹«åŠ©ä½¿ç”¨è€…åˆ©ç”¨è³‡æ–™å›ç­”å•é¡Œã€‚`;

        let responseFormat = hasPreviousSummary
            ? `**ä¸€èˆ¬å›ç­”æ­¥é©Ÿ (è‹¥éæ¨è«–è«‹æ±‚)ï¼š** 1. å›é¡§ç¸½çµ 2. å®šä½æ–°è­‰æ“š 3. é€£çµã€‚`
            : `**ä¸€èˆ¬å›ç­”æ­¥é©Ÿ (è‹¥éæ¨è«–è«‹æ±‚)ï¼š** 1. å®šä½èˆ‡æ‘˜è¦ 2. æä¾›æ‘˜è¦èˆ‡ä½ç½® 3. è§£é‡‹ç›¸é—œæ€§ã€‚`;

        systemPrompt = `
            ${baseInstructions}
            ${inferenceInstructions}
            ${responseFormat}
            **è¼¸å‡ºæ ¼å¼ (ç¹é«”ä¸­æ–‡)ï¼š**
            å¦‚æœæ˜¯æ¨è«–è«‹æ±‚ï¼Œè«‹ä¾ç…§ã€ŒN+1 æ¨è«–æ©Ÿåˆ¶ã€çš„æ ¼å¼è¼¸å‡ºã€‚
            å¦å‰‡è«‹ä¾ç…§ä¸€èˆ¬å›ç­”æ­¥é©Ÿã€‚
        `;

        // --- å»ºç«‹å…§å®¹ parts ---
        const contentParts = [
          { text: `ä½¿ç”¨è€…å®šç¾©çš„æœ¬æ¬¡æ¢ç´¢ç›®æ¨™ï¼ˆå•é¡Œï¼‰æ˜¯ï¼š${problemStatement || 'ç„¡æ˜ç¢ºç›®æ¨™'}` },
          { text: "é€™æ˜¯æˆ‘çš„åŸå§‹é€å­—ç¨¿ï¼š\n" + (transcript || "ä½¿ç”¨è€…å°šæœªæä¾›é€å­—ç¨¿ã€‚") },
        ];

        // åŸå§‹åœ–ç‰‡
        images.forEach((img, i) => {
          contentParts.push({ text: `åŸå§‹æˆªåœ– ${i + 1} (åç¨±: ${img.name})ï¼š` });
          const base64Data = img.base64.split(',')[1];
          const mimeTypeMatch = img.base64.match(/data:([a-zA-Z0-9]+\/[a-zA-Z0-9-.+]+).*,.*/);
          const mimeType = mimeTypeMatch ? mimeTypeMatch[1] : 'image/jpeg';
          contentParts.push({ inlineData: { mimeType: mimeType, data: base64Data } });
        });

        // --- åŠ å…¥ N+1 è£œå……è³‡æ–™ ---
        if (suppText.trim() || suppFiles.length > 0) {
            contentParts.push({ text: "\n=== ä½¿ç”¨è€…æä¾›çš„è£œå……é©—è­‰è³‡æ–™ (N+1) ===\nè«‹ä½¿ç”¨ä»¥ä¸‹è³‡æ–™ä¾†é©—è­‰æˆ–ä¿®æ­£ä½ çš„æ¨è«–ï¼Œæˆ–å›ç­”éœ€è¦æ›´å¤šè³‡è¨Šçš„å•é¡Œã€‚" });
            
            if (suppText.trim()) {
                contentParts.push({ text: `è£œå……æ–‡å­—èªªæ˜ï¼š\n${suppText}` });
            }

            suppFiles.forEach((file, i) => {
                if (file.type === 'text') {
                    contentParts.push({ text: `è£œå……æ–‡ä»¶ ${i + 1} (${file.name}) å…§å®¹ï¼š\n${file.content}` });
                } else if (file.type === 'image') {
                    contentParts.push({ text: `è£œå……æˆªåœ– ${i + 1} (åç¨±: ${file.name})ï¼š` });
                    const base64Data = file.content.split(',')[1];
                    const mimeTypeMatch = file.content.match(/data:([a-zA-Z0-9]+\/[a-zA-Z0-9-.+]+).*,.*/);
                    const mimeType = mimeTypeMatch ? mimeTypeMatch[1] : 'image/jpeg';
                    contentParts.push({ inlineData: { mimeType: mimeType, data: base64Data } });
                }
            });
        }

        if (hasPreviousSummary) {
          contentParts.push({ text: `é€™æ˜¯æˆ‘ã€Œå…ˆå‰ã€å¾—åˆ°çš„ç¸½çµå…§å®¹ï¼š\n${categorization}` });
        }

        contentParts.push({ text: `æˆ‘çš„æœ€æ–°å•é¡Œæ˜¯ï¼š${currentQuery}` });

        const contents = [{ role: "user", parts: contentParts }];

        // --- å‘¼å« API ---
        const modelResponseText = await callGeminiAPI(contents, systemPrompt);
        const newModelMessage = { role: 'model', text: modelResponseText };
        setChatHistory(prev => [...prev, newModelMessage]);
      };

      /**
       * è™•ç†ç¸½çµæ­¸é¡
       */
      const handleCategorize = async () => {
        if (isLoading || isQuizLoading || (!transcript && images.length === 0 && chatHistory.length === 0 && !importedSummary)) {
          setCategorization("è«‹å…ˆæä¾›è³‡æ–™æˆ–åŒ¯å…¥ä¸Šæ¬¡çš„ç¸½çµï¼Œæˆ‘æ‰èƒ½å¹«æ‚¨å½™æ•´ç¸½çµã€‚");
          return;
        }
        setQuizContent('');

        const integrationPrompt = importedSummary ?
          "**é‡è¦æŒ‡ä»¤ï¼š** æä¾›äº†ã€Œä¸Šæ¬¡çš„æ¢ç´¢ç¸½çµçµæœã€ã€‚è«‹å°‡å…¶å…§å®¹èˆ‡æœ¬æ¬¡æä¾›çš„æ‰€æœ‰æ–°è³‡æ–™å’Œå°è©±é€²è¡Œæ™ºæ…§å½™æ•´ï¼Œä¸¦è¼¸å‡ºä¸€å€‹å…¨é¢ã€å‡ç´šä¸”æ›´å®Œæ•´çš„ç¸½çµã€‚" : "";

        const systemPrompt = `
              ä½ æ˜¯ä¸€å€‹ç¸½çµåŠ©æ‰‹ã€‚
              ${integrationPrompt}
              è«‹æ ¹æ“šä»¥ä¸‹ä½¿ç”¨è€…å®šç¾©çš„ç›®æ¨™ã€æä¾›çš„é€å­—ç¨¿ã€åœ–ç‰‡ã€è£œå……è³‡æ–™ä»¥åŠæˆ‘å€‘çš„å°è©±è¨˜éŒ„ï¼Œå¹«åŠ©ä½¿ç”¨è€…ç¸½çµä»–å€‘åœ¨å°è©±ä¸­ã€Œè‡ªå·±ç™¼ç¾ã€çš„é‡é»ï¼Œä¸¦ä¸”ç¸½çµå…§å®¹å¿…é ˆåœç¹è‘—ã€Œ${problemStatement || 'å½±ç‰‡çš„ä¸»è¦å…§å®¹'}ã€ä¾†å›ç­”ã€‚
              æ ¼å¼ç¯„ä¾‹ï¼š
              **è§£æ±ºç›®æ¨™ï¼š** [ç›®æ¨™]
              **æ‘˜è¦/ç™¼ç¾ï¼š** [çµè«–]
              **åˆ†é¡æ¨™ç±¤ï¼š** #æ¨™ç±¤A
            `;

        // å»ºæ§‹ç¸½çµç”¨çš„ contextï¼Œä¹Ÿéœ€è¦åŒ…å«è£œå……è³‡æ–™
        const contentParts = [
          { text: `ä½¿ç”¨è€…å®šç¾©çš„æœ¬æ¬¡æ¢ç´¢ç›®æ¨™ï¼ˆå•é¡Œï¼‰æ˜¯ï¼š${problemStatement || 'ç„¡æ˜ç¢ºç›®æ¨™'}` },
          { text: "é€™æ˜¯æˆ‘çš„é€å­—ç¨¿ï¼š\n" + (transcript || "æœªæä¾›") },
        ];
        
        images.forEach((img, i) => { /* ç°¡ç•¥ï¼šæ·»åŠ åŸå§‹åœ–ç‰‡é‚è¼¯ (åŒ handleQuerySubmit) */
             const base64Data = img.base64.split(',')[1];
             const mimeTypeMatch = img.base64.match(/data:([a-zA-Z0-9]+\/[a-zA-Z0-9-.+]+).*,.*/);
             contentParts.push({ text: `æˆªåœ– ${i+1}:`, inlineData: { mimeType: mimeTypeMatch?mimeTypeMatch[1]:'image/jpeg', data: base64Data } });
        });

        // æ·»åŠ è£œå……è³‡æ–™è‡³ç¸½çµ
        if (suppText.trim() || suppFiles.length > 0) {
             contentParts.push({ text: "è£œå……é©—è­‰è³‡æ–™ï¼š" + suppText });
             suppFiles.forEach(f => {
                 if(f.type === 'text') contentParts.push({ text: `è£œå……æ–‡ä»¶ (${f.name}): ${f.content}` });
                 if(f.type === 'image') {
                     const b64 = f.content.split(',')[1];
                     const mime = f.content.match(/data:([a-zA-Z0-9]+\/[a-zA-Z0-9-.+]+).*,.*/);
                     contentParts.push({ text: `è£œå……åœ–ç‰‡ (${f.name}):`, inlineData: { mimeType: mime?mime[1]:'image/jpeg', data: b64 }});
                 }
             });
        }

        contentParts.push({ text: `ä¸Šæ¬¡åŒ¯å…¥ç¸½çµï¼š\n${importedSummary || 'ç„¡'}` });
        contentParts.push({ text: "å°è©±è¨˜éŒ„ï¼š\n" + chatHistory.map(msg => `${msg.role === 'user' ? 'æˆ‘' : 'æ•™ç·´'}: ${msg.text}`).join('\n') });
        contentParts.push({ text: "è«‹æ ¹æ“šä»¥ä¸Šè³‡æ–™ç¸½çµã€‚" });

        const contents = [{ role: "user", parts: contentParts }];
        const categorizationText = await callGeminiAPI(contents, systemPrompt);
        setCategorization(categorizationText);
      };

      const ModelMessage = ({ text }) => (
        <div className="flex justify-start">
          <div className="max-w-xs lg:max-w-md px-4 py-3 rounded-lg shadow-md bg-white text-gray-800 border border-gray-200 ai-response-block">
            <pre className="whitespace-pre-wrap">{text}</pre>
          </div>
        </div>
      );

      const isOverallLoading = isLoading || isQuizLoading;

      return (
        <div className="flex flex-col md:flex-row h-screen bg-gray-100 font-sans text-gray-800">
          {/* ----- å·¦å´ï¼šè³‡æ–™ä¸Šå‚³é¢æ¿ ----- */}
          <div className={`${isSidebarOpen ? 'w-full md:w-4/12 lg:w-3/12' : 'hidden'} p-4 overflow-y-auto space-y-4 border-r border-gray-300 min-h-[40vh] md:h-full transition-all duration-300 ease-in-out bg-gray-50`}>
            
            {/* 1. è¨­å®šèˆ‡è³‡æ–™ */}
            <div className="flex justify-between items-center">
              <h2 className="text-xl font-bold text-gray-700">1. åŸºç¤è¨­å®šèˆ‡è³‡æ–™</h2>
              <button onClick={() => setIsSidebarOpen(false)} className="md:hidden text-gray-500 hover:text-gray-700">
                <svg xmlns="http://www.w3.org/2000/svg" className="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M6 18L18 6M6 6l12 12" /></svg>
              </button>
            </div>

            <div className="bg-white p-4 rounded-lg shadow-md border border-indigo-200">
              <label htmlFor="problemStatement" className="block text-lg font-bold text-indigo-700 mb-2">æœ¬æ¬¡æ¢ç´¢ç›®æ¨™</label>
              <textarea
                id="problemStatement"
                rows="2"
                className="w-full p-2 border border-indigo-300 rounded-lg focus:ring-2 focus:ring-indigo-500 focus:outline-none text-sm"
                placeholder="ä¾‹å¦‚ï¼šé€™éƒ¨å½±ç‰‡æ˜¯å¦æ”¯æŒ..."
                value={problemStatement}
                onChange={(e) => setProblemStatement(e.target.value)}
                disabled={isOverallLoading}
              />
            </div>

            <div className="bg-white p-4 rounded-lg shadow-md border border-yellow-200">
              <label className="block text-sm font-bold text-yellow-700 mb-1">åŒ¯å…¥ä¸Šæ¬¡ç¸½çµ (.md/.txt)</label>
              <input type="file" accept=".md,.txt" onChange={handleImport} className="block w-full text-xs text-gray-500 file:mr-2 file:py-1 file:px-2 file:rounded-full file:border-0 file:text-xs file:font-semibold file:bg-yellow-50 file:text-yellow-700 hover:file:bg-yellow-100" disabled={isOverallLoading}/>
              {importedSummary && <p className="mt-1 text-xs text-yellow-600 truncate">å·²è¼‰å…¥ï¼š{importedFileName}</p>}
            </div>

            <div>
              <label className="block text-sm font-medium text-gray-600 mb-1">åŸºç¤é€å­—ç¨¿</label>
              <textarea rows="4" className="w-full p-2 border border-gray-300 rounded-lg shadow-sm text-sm" placeholder="è²¼ä¸Šé€å­—ç¨¿..." value={transcript} onChange={(e) => setTranscript(e.target.value)} disabled={isOverallLoading}/>
            </div>

            <div>
              <label className="block text-sm font-medium text-gray-600 mb-1">åŸºç¤æˆªåœ–</label>
              <input type="file" multiple accept="image/*" onChange={handleImageUpload} className="block w-full text-xs text-gray-500 file:mr-2 file:py-1 file:px-2 file:rounded-full file:border-0 file:text-xs file:font-semibold file:bg-blue-50 file:text-blue-700 hover:file:bg-blue-100" disabled={isOverallLoading}/>
              {images.length > 0 && (
                <div className="grid grid-cols-3 gap-2 mt-2">
                  {images.map((img, idx) => (
                    <div key={idx} className="relative group"><img src={img.base64} className="w-full h-16 object-cover rounded border"/><button onClick={()=>removeImage(idx)} className="absolute top-0 right-0 bg-red-500 text-white rounded-full w-4 h-4 flex items-center justify-center text-xs opacity-0 group-hover:opacity-100">Ã—</button></div>
                  ))}
                </div>
              )}
            </div>
            
            <hr className="border-gray-300 my-2" />

            {/* 4. N+1 é©—è­‰è³‡æ–™å€å¡Š (New) */}
            <div className="bg-orange-50 p-3 rounded-lg border border-orange-200">
              <h2 className="text-lg font-bold text-orange-800 mb-2 flex items-center">
                 N+1 é©—è­‰è³‡æ–™
                 <span className="ml-2 text-xs font-normal bg-orange-200 text-orange-800 px-2 py-0.5 rounded-full">æå‡æº–ç¢ºåº¦</span>
              </h2>
              
              {/* æ–‡å­—è£œå…… */}
              <label className="block text-sm font-medium text-orange-700 mb-1">è£œå……æ–‡å­—/è§€å¯Ÿï¼š</label>
              <textarea
                rows="3"
                className="w-full p-2 border border-orange-300 rounded bg-white text-sm mb-3 focus:ring-2 focus:ring-orange-400 focus:outline-none"
                placeholder="ç›´æ¥è²¼ä¸Šæ–°çš„è­‰æ“šæ–‡å­—..."
                value={suppText}
                onChange={(e) => setSuppText(e.target.value)}
                disabled={isOverallLoading}
              />

              {/* æª”æ¡ˆè£œå…… */}
              <label className="block text-sm font-medium text-orange-700 mb-1">ä¸Šå‚³ä½è­‰æª”æ¡ˆ (PDF, TXT, åœ–ç‰‡)ï¼š</label>
              <input
                type="file"
                multiple
                accept=".pdf,.txt,image/*"
                onChange={handleSuppFileUpload}
                className="block w-full text-xs text-gray-500
                      file:mr-2 file:py-1 file:px-2
                      file:rounded-full file:border-0
                      file:text-xs file:font-semibold
                      file:bg-orange-100 file:text-orange-700
                      hover:file:bg-orange-200"
                disabled={isOverallLoading}
              />

              {/* è£œå……æª”æ¡ˆåˆ—è¡¨ */}
              {suppFiles.length > 0 && (
                <div className="mt-2 space-y-1">
                    {suppFiles.map((file, idx) => (
                        <div key={idx} className="flex items-center justify-between bg-white p-1.5 rounded border border-orange-100 text-xs">
                            <span className="truncate max-w-[80%] text-gray-600" title={file.name}>
                                {file.type === 'image' ? 'ğŸ–¼ï¸' : (file.name.endsWith('.pdf') ? 'ğŸ“„' : 'ğŸ“')} {file.name}
                            </span>
                            <button onClick={() => removeSuppFile(idx)} className="text-red-500 hover:text-red-700 font-bold px-1">Ã—</button>
                        </div>
                    ))}
                </div>
              )}
            </div>

          </div>

          {/* ----- å³å´ï¼šäº’å‹•èˆ‡ç¸½çµ ----- */}
          <div className={`${isSidebarOpen ? 'w-full md:w-8/12 lg:w-9/12' : 'w-full'} p-4 flex flex-col h-full transition-all duration-300 ease-in-out relative`}>

            {!isSidebarOpen && (
              <button onClick={() => setIsSidebarOpen(true)} className="absolute top-4 left-4 z-10 p-2 bg-white border border-gray-300 rounded-md shadow-sm hover:bg-gray-100 text-gray-600">
                <svg xmlns="http://www.w3.org/2000/svg" className="h-5 w-5" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M4 6h16M4 12h16M4 18h16" /></svg>
              </button>
            )}
             {isSidebarOpen && (
              <button onClick={() => setIsSidebarOpen(false)} className="hidden md:block absolute top-6 left-[-12px] z-10 p-1 bg-white border border-gray-300 rounded-full shadow-md hover:bg-gray-100 text-gray-500">
                <svg xmlns="http://www.w3.org/2000/svg" className="h-4 w-4" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M15 19l-7-7 7-7" /></svg>
              </button>
            )}

            {/* èŠå¤©ä»‹é¢ */}
            <div className="flex-1 md:min-h-[35rem] flex flex-col border border-gray-300 rounded-lg shadow-lg bg-white overflow-hidden">
              <h2 className="text-2xl font-bold text-gray-700 p-4 border-b border-gray-200 pl-8 md:pl-4">
                2. é–‹å§‹æ¢ç´¢èˆ‡è­‰æ“šåˆ†æ
              </h2>

              <div className="flex-1 p-4 overflow-y-auto space-y-4 bg-gray-50">
                {chatHistory.length === 0 && (
                  <div className="text-center text-gray-500 mt-8">
                    <p>è«‹å…ˆè¨­å®šç›®æ¨™ä¸¦ä¸Šå‚³è³‡æ–™ã€‚</p>
                    <p className="text-sm">è‹¥æ•™ç·´è¦æ±‚è£œå……è³‡æ–™ï¼Œè«‹ä½¿ç”¨å·¦å´çš„ã€ŒN+1 é©—è­‰è³‡æ–™ã€å€å¡Šä¸Šå‚³ã€‚</p>
                  </div>
                )}
                {chatHistory.map((msg, index) => (
                  msg.role === 'user' ? (
                    <div key={index} className="flex justify-end">
                      <div className="max-w-xs lg:max-w-md px-4 py-3 rounded-lg shadow-md bg-blue-600 text-white">{msg.text}</div>
                    </div>
                  ) : (
                    <ModelMessage key={index} text={msg.text} />
                  )
                ))}
                {isLoading && (
                  <div className="flex justify-start"><div className="px-4 py-3 rounded-lg shadow-md bg-white text-gray-800 border border-gray-200">Thinking...</div></div>
                )}
              </div>

              <form onSubmit={handleQuerySubmit} className="p-4 border-t border-gray-200 bg-white">
                <div className="flex space-x-2">
                  <input
                    type="text"
                    className="flex-1 p-3 border border-gray-300 rounded-lg shadow-sm focus:ring-2 focus:ring-blue-500 focus:outline-none"
                    placeholder="æå•..."
                    value={userQuery}
                    onChange={(e) => setUserQuery(e.target.value)}
                    disabled={isOverallLoading}
                  />
                  <button
                    type="submit"
                    className="px-6 py-3 bg-blue-600 text-white font-semibold rounded-lg shadow-md hover:bg-blue-700 disabled:opacity-50 btn-fancy"
                    disabled={isOverallLoading || !userQuery.trim()}
                  >
                    {hasPreviousSummary ? 'è¿½å•' : 'ç™¼é€'}
                  </button>
                </div>
              </form>
            </div>

            {/* ç¸½çµæ­¸é¡ */}
            <div className="mt-4 p-4 border border-gray-300 rounded-lg shadow-lg bg-white">
              <div className="flex justify-between items-center mb-3">
                  <h2 className="text-2xl font-bold text-gray-700">3. ç¸½çµæ­¸é¡èˆ‡å½™æ•´</h2>
              </div>
              <button
                onClick={handleCategorize}
                className="w-full px-6 py-3 bg-green-600 text-white font-semibold rounded-lg shadow-md hover:bg-green-700 disabled:opacity-50 btn-fancy"
                disabled={isOverallLoading}
              >
                {isLoading ? 'è™•ç†ä¸­...' : 'ç¸½çµæˆ‘çš„ç™¼ç¾ (å« N+1 è³‡æ–™)'}
              </button>

              {categorization && (
                <div className="mt-4 p-4 bg-green-50 border border-green-200 rounded-lg">
                  <h3 className="font-bold text-green-800">æœ¬æ¬¡ç¸½çµï¼š</h3>
                  <pre className="whitespace-pre-wrap font-sans text-gray-700 mt-2">{categorization}</pre>
                  <div className="mt-3 flex flex-wrap gap-2">
                    <button onClick={handleGenerateQuestions} disabled={isOverallLoading} className="px-4 py-2 bg-purple-600 text-white font-semibold rounded-lg shadow-md hover:bg-purple-700 btn-fancy text-sm">{isQuizLoading ? 'ç”Ÿæˆä¸­...' : 'ç”Ÿæˆæ¸¬é©—é¡Œ âœ¨'}</button>
                    <button onClick={() => {setCategorization(''); setQuizContent('');}} className="px-4 py-2 bg-yellow-500 text-white font-semibold rounded-lg shadow-md hover:bg-yellow-600 btn-fancy text-sm" disabled={isOverallLoading}>æ¸…é™¤ç¸½çµ</button>
                    <button onClick={handleExport} className="px-4 py-2 bg-indigo-600 text-white font-semibold rounded-lg shadow-md hover:bg-indigo-700 btn-fancy text-sm" disabled={isOverallLoading}>åŒ¯å‡ºç¸½çµ</button>
                  </div>

                  {isQuizLoading && <div className="mt-4 text-center text-purple-700">æ¸¬é©—é¡Œç”Ÿæˆä¸­...</div>}
                  {quizContent && !isQuizLoading && (
                    <div className="mt-4 p-4 bg-purple-50 border border-purple-200 rounded-lg ai-response-block">
                      <h3 className="font-bold text-purple-800 mb-2">æ¸¬é©—èˆ‡åæ€é¡Œ</h3>
                      <pre className="whitespace-pre-wrap font-sans text-gray-700">{quizContent}</pre>
                    </div>
                  )}
                </div>
              )}
            </div>
          </div>
        </div>
      );
    }

    ReactDOM.createRoot(document.getElementById('root')).render(<App />);
  </script>
</body>
</html>