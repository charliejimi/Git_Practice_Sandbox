<!DOCTYPE html>
<html lang="zh-Hant">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>螢幕錄製與 AI 註解工具 (含 Word 匯出)</title>
    <!-- 載入 Tailwind CSS 以進行快速美化 -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- 載入 FileSaver.js 函式庫，用於在客戶端儲存檔案 (如 .doc) -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/FileSaver.js/2.0.5/FileSaver.min.js"></script>
    <!-- 移除 PDF 相關的函式庫 (dompurify, html2canvas, jspdf) -->
    
    <style>
        /* 使用 Inter 字體 */
        body {
            font-family: 'Inter', sans-serif;
        }
        /* 自訂按鈕禁用時的樣式 */
        button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        /* AI 註解的讀取中旋轉動畫 */
        .spinner {
            border: 2px solid rgba(0, 0, 0, 0.1);
            border-left-color: #4A90E2;
            border-radius: 50%;
            width: 16px;
            height: 16px;
            animation: spin 1s linear infinite;
        }
        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        /* 列印專用樣式 (保留，以防萬一) */
        @media print {
            /* 隱藏所有不需要列印的 UI 元素 */
            body > div:not(.printable-area), 
            .controls-area, 
            #previewContainer,
            #playbackContainer video,
            #playbackContainer #downloadLink,
            /* 移除 pdfExportButton 的隱藏樣式 */
            #playbackContainer #wordExportButton, 
            #errorBox,
            #llmStatus,
            .action-buttons, 
            .image-upload-area, 
            .app-header, 
            .title-input-area, 
            #playbackHeader, 
            #screenshotsResultArea h2
             { 
                display: none !important;
            }
            
            /* 確保自訂標題在列印時顯示 */
            .print-only {
                display: block !important;
            }
            
            /* 確保結果區域填滿頁面 */
            .printable-area {
                width: 100% !important;
                max-width: 100% !important;
                margin: 0 !important;
                padding: 0 !important;
                box-shadow: none !important;
                border: none !important;
            }

            /* 每個截圖項目的列印樣式 */
            .screenshot-item {
                page-break-inside: avoid; /* 避免圖片和文字被切斷 */
                page-break-after: always; /* 每個項目一頁 */
                padding: 20px;
                border: none !important; /* 移除邊框 */
                box-shadow: none !important; /* 移除陰影 */
            }
            .screenshot-item:last-child {
                page-break-after: avoid; /* 最後一項後面不要分頁 */
            }

            .screenshot-item img {
                max-width: 100% !important;
                height: auto;
                border: 1px solid #ccc;
            }
            
            /* 確保註解文字樣式在列印時正確 */
            .screenshot-item textarea {
                border: none !important;
                resize: none !important;
                overflow: hidden !important;
                height: auto !important;
                min-height: 40px;
                /* 為了列印，讓 textarea 內容看起來像普通文字 */
                background-color: transparent !important;
                padding: 0 !important; 
                margin: 0 !important;
                box-shadow: none !important;
            }
            
            /* 覆寫 AI 註解標題為「註解」 */
            .screenshot-item h4.print-only-label {
                 color: #000;
                 font-size: 1rem;
            }
            .screenshot-item h4.print-only-label::before {
                content: "註解:"; /* 使用偽元素替換文字 */
            }
            .screenshot-item h4.print-only-label {
                /* 讓 h4 原本的內容不顯示 (防止「AI 註解:」出現) */
                font-size: 0;
                color: transparent;
                display: inline;
            }
            .screenshot-item h4.print-only-label::before {
                font-size: 1rem; /* 恢復字體大小 */
                color: #000; /* 恢復字體顏色 */
                font-weight: 600;
                content: "註解:";
            }
            
            /* 調整步驟區域的間距 */
            #screenshotsResultArea {
                margin-top: 0 !important;
                padding-top: 0 !important;
            }
        }
    </style>
</head>
<body class="bg-gray-100 min-h-screen flex items-center justify-center p-4">

    <!-- 應用程式主體容器 -->
    <div class="bg-white w-full max-w-4xl rounded-lg shadow-xl p-6 md:p-8 printable-area">
        
        <!-- 應用程式主標題和描述 (controls-area 用於非列印時的 Flex 佈局) -->
        <div class="app-header controls-area"> 
            <h1 class="text-3xl font-bold text-center text-gray-800 mb-2">螢幕錄製與 AI 註解工具</h1>
            <p class="text-center text-gray-500 mb-6 description-paragraph">點擊「開始錄製」，將會**每 2 秒自動擷取畫面**，您也可手動擷取。</p>
        </div>

        <!-- 新增：手動輸入文件標題 -->
        <div class="mb-6 title-input-area">
            <label for="documentTitleInput" class="block text-sm font-medium text-gray-700 mb-1">匯出文件標題 (手動輸入):</label>
            <input type="text" id="documentTitleInput" 
                   value="自動化 SOP 報告" 
                   placeholder="請輸入您的報告標題"
                   class="w-full px-4 py-2 border border-gray-300 rounded-lg shadow-sm focus:ring-blue-500 focus:border-blue-500">
        </div>

        <!-- 列印專用標題 (預設隱藏，列印時顯示) -->
        <div id="printableTitle" class="hidden text-3xl font-bold text-gray-900 mb-8 text-center print-only"></div>

        <!-- 控制按鈕 (增加 'controls-area' class) -->
        <div class="flex items-center justify-center flex-wrap gap-4 mb-6 controls-area">
            <button id="startButton" class="px-6 py-3 bg-blue-600 text-white rounded-lg font-medium shadow-md hover:bg-blue-700 transition-all focus:outline-none focus:ring-2 focus:ring-blue-500 focus:ring-opacity-50">
                開始錄製
            </button>
            <button id="screenshotButton" class="px-6 py-3 bg-yellow-500 text-white rounded-lg font-medium shadow-md hover:bg-yellow-600 transition-all focus:outline-none focus:ring-2 focus:ring-yellow-400 focus:ring-opacity-50" disabled>
                擷取螢幕 (手動)
            </button>
            <button id="stopButton" class="px-6 py-3 bg-red-600 text-white rounded-lg font-medium shadow-md hover:bg-red-700 transition-all focus:outline-none focus:ring-2 focus:ring-red-500 focus:ring-opacity-50" disabled>
                停止錄製
            </button>
        </div>

        <!-- 錯誤訊息區域 -->
        <div id="errorBox" class="bg-red-100 border border-red-400 text-red-700 px-4 py-3 rounded-lg relative mb-6" role="alert" hidden>
            <strong class="font-bold">錯誤：</strong>
            <span id="errorMessage" class="block sm:inline"></span>
        </div>

        <!-- 即時預覽區域 -->
        <div id="previewContainer" class="mb-6" hidden>
            <h2 class="text-xl font-semibold text-gray-700 mb-3">即時預覽</h2>
            <video id="previewVideo" class="w-full h-auto bg-gray-200 rounded-lg shadow-inner" autoplay muted></video>
        </div>
        
        <!-- 錄製結果區域 -->
        <div id="playbackContainer" class="text-center" hidden>
            <h2 id="playbackHeader" class="text-xl font-semibold text-gray-700 mb-3">錄製結果</h2>
            <video id="playbackVideo" class="w-full h-auto bg-gray-200 rounded-lg shadow-inner mb-4" controls></video>
            
            <!-- 狀態訊息 -->
            <p id="llmStatus" class="text-center text-gray-600 my-4" hidden></p>
            
            <!-- (修改) 下載按鈕群組 -->
            <div class="flex items-center justify-center flex-wrap gap-4 export-buttons">
                <a id="downloadLink" class="inline-block px-6 py-3 bg-green-600 text-white rounded-lg font-medium shadow-md hover:bg-green-700 transition-all" hidden>
                    下載影片 (.webm)
                </a>
                <!-- 移除 pdfExportButton -->
                <!-- 匯出為 Word (.doc) 按鈕 -->
                <button id="wordExportButton" class="inline-block px-6 py-3 bg-orange-600 text-white rounded-lg font-medium shadow-md hover:bg-orange-700 transition-all" hidden>
                    匯出為 Word (.doc)
                </button>
            </div>

            <!-- AI 註解結果顯示區域 -->
            <div id="screenshotsResultArea" class="mt-10 text-left border-t pt-6">
                <!-- AI 產生的截圖與註解將會顯示在這裡 -->
            </div>
            
            <button id="insertFinalStepButton" onclick="insertBlankStep(screenshotCache.length - 1)" class="w-full px-6 py-3 mt-4 border border-dashed border-gray-400 text-gray-600 rounded-lg font-medium hover:bg-gray-100 transition-all" hidden>
                + 在結尾新增一個空步驟 +
            </button>
        </div>

    </div>

    <!-- 隱藏的 Canvas 用於擷取畫面 -->
    <canvas id="screenshotCanvas" class="hidden"></canvas>

    <script>
        // --- 獲取 DOM 元素 ---
        const startButton = document.getElementById('startButton');
        const stopButton = document.getElementById('stopButton');
        const screenshotButton = document.getElementById('screenshotButton');
        const previewVideo = document.getElementById('previewVideo');
        const playbackVideo = document.getElementById('playbackVideo');
        const downloadLink = document.getElementById('downloadLink');
        // 移除 pdfExportButton
        const wordExportButton = document.getElementById('wordExportButton'); 
        const errorBox = document.getElementById('errorBox');
        const errorMessage = document.getElementById('errorMessage');
        const previewContainer = document.getElementById('previewContainer');
        const playbackContainer = document.getElementById('playbackContainer');
        const screenshotCanvas = document.getElementById('screenshotCanvas');
        const llmStatus = document.getElementById('llmStatus');
        const screenshotsResultArea = document.getElementById('screenshotsResultArea');
        const insertFinalStepButton = document.getElementById('insertFinalStepButton');
        const documentTitleInput = document.getElementById('documentTitleInput');
        const printableTitle = document.getElementById('printableTitle');

        // --- 全局變數 ---
        let mediaRecorder;
        let recordedChunks = [];
        let screenshotCache = []; 
        let stream; 
        let screenshotIntervalId = null; 
        const AUTO_CAPTURE_DELAY = 2000; 

        // --- 設置標題、錯誤訊息、重設 UI 函式 ---
        printableTitle.textContent = documentTitleInput.value;
        documentTitleInput.addEventListener('input', (e) => {
            printableTitle.textContent = e.target.value;
        });

        function showError(message) {
            errorMessage.textContent = message;
            errorBox.hidden = false;
        }

        function hideError() {
            errorBox.hidden = true;
        }

        function resetUI() {
            if (screenshotIntervalId) {
                clearInterval(screenshotIntervalId);
                screenshotIntervalId = null;
            }
            startButton.disabled = false;
            stopButton.disabled = true;
            screenshotButton.disabled = true;
            previewContainer.hidden = true;
            playbackContainer.hidden = true;
            downloadLink.hidden = true;
            // 移除 pdfExportButton 的隱藏
            wordExportButton.hidden = true; 
            llmStatus.hidden = true;
            insertFinalStepButton.hidden = true; 
            screenshotsResultArea.innerHTML = '';
            previewVideo.srcObject = null;
            playbackVideo.src = '';
            downloadLink.href = '';
            screenshotCache = [];
            recordedChunks = [];
        }


        // --- 擷取螢幕畫面函式 ---
        function takeScreenshot() {
            if (!stream || !previewVideo || mediaRecorder.state !== 'recording') {
                return;
            }
            try {
                const videoTrack = stream.getVideoTracks()[0];
                const settings = videoTrack.getSettings();
                screenshotCanvas.width = settings.width || previewVideo.videoWidth;
                screenshotCanvas.height = settings.height || previewVideo.videoHeight;
                const context = screenshotCanvas.getContext('2d');
                context.drawImage(previewVideo, 0, 0, screenshotCanvas.width, screenshotCanvas.height);
                const imageDataUrl = screenshotCanvas.toDataURL('image/jpeg', 0.8);
                screenshotCache.push({ 
                    imageDataUrl: imageDataUrl, 
                    annotation: null, 
                    status: 'pending' 
                });
                llmStatus.textContent = `已擷取畫面 ${screenshotCache.length} 張 (自動/手動)。`;
                llmStatus.hidden = false;
            } catch (err) {
                console.error("擷取螢幕失敗:", err);
                if (mediaRecorder.state === 'recording' && screenshotIntervalId === null) {
                    showError(`擷取螢幕失敗: ${err.message}`);
                }
            }
        }

        function resizeImage(base64, maxWidth = 750) {
            return new Promise(resolve => {
                const img = new Image();
                img.onload = () => {
                    const scale = maxWidth / img.width;
                    const newWidth = img.width > maxWidth ? maxWidth : img.width;
                    const newHeight = img.width > maxWidth ? img.height * scale : img.height;
                    const canvas = document.createElement("canvas");
                    canvas.width = newWidth;
                    canvas.height = newHeight;
                    const ctx = canvas.getContext("2d");
                    ctx.drawImage(img, 0, 0, newWidth, newHeight);
                    resolve(canvas.toDataURL("image/jpeg", 0.85));
                };
                img.onerror = () => {
                    console.error("圖片載入失敗，返回原 Base64 資料");
                    resolve(base64);
                };
                img.src = base64;
            });
        }


        // --- 開始錄製、停止錄製、擷取螢幕 事件 ---
        startButton.addEventListener('click', async () => {
            hideError();
            playbackContainer.hidden = true;
            screenshotsResultArea.innerHTML = '';
            recordedChunks = [];
            screenshotCache = [];
            insertFinalStepButton.hidden = true;
            wordExportButton.hidden = true; 
            // 移除 pdfExportButton 的隱藏
            

            try {
                stream = await navigator.mediaDevices.getDisplayMedia({
                    video: true,
                    audio: true 
                });
                previewContainer.hidden = false;
                previewVideo.srcObject = stream;
                previewVideo.play(); 
                const options = { mimeType: 'video/webm; codecs=vp9' };
                if (!MediaRecorder.isTypeSupported(options.mimeType)) {
                    options.mimeType = 'video/webm';
                }
                mediaRecorder = new MediaRecorder(stream, options);
                mediaRecorder.ondataavailable = (event) => {
                    if (event.data.size > 0) {
                        recordedChunks.push(event.data);
                    }
                };
                mediaRecorder.onstop = async () => {
                    if (screenshotIntervalId) {
                        clearInterval(screenshotIntervalId);
                        screenshotIntervalId = null;
                    }
                    const blob = new Blob(recordedChunks, { type: 'video/webm' });
                    const url = URL.createObjectURL(blob);
                    playbackVideo.src = url;
                    playbackContainer.hidden = false;
                    downloadLink.href = url;
                    downloadLink.download = `screen-recording-${new Date().toISOString().substring(0, 19).replace('T', '_').replace(/:/g, '-')}.webm`;
                    downloadLink.hidden = false;
                    previewContainer.hidden = true;
                    previewVideo.srcObject = null;
                    await processScreenshotsWithLLM();
                };
                stream.getTracks().forEach(track => {
                    track.onended = () => {
                        if (mediaRecorder.state === 'recording') {
                            stopButton.click();
                        }
                    };
                });
                mediaRecorder.start();
                screenshotIntervalId = setInterval(takeScreenshot, AUTO_CAPTURE_DELAY);
                startButton.disabled = true; 
                stopButton.disabled = false; 
                screenshotButton.disabled = false;
            } catch (err) {
                console.error("無法開始錄製:", err);
                showError(`錯誤： ${err.message}.`);
                resetUI();
            }
        });

        stopButton.addEventListener('click', () => {
            if (mediaRecorder && mediaRecorder.state === 'recording') {
                if (screenshotIntervalId) {
                    clearInterval(screenshotIntervalId);
                    screenshotIntervalId = null;
                }
                mediaRecorder.stop();
                if (stream) {
                    stream.getTracks().forEach(track => track.stop());
                }
                startButton.disabled = false;
                stopButton.disabled = true;
                screenshotButton.disabled = true;
            }
        });

        screenshotButton.addEventListener('click', takeScreenshot); 


        // --- AI 視覺分析函式 ---
        async function callGeminiVision(base64ImageData, mimeType, previousBase64Data = null, previousMimeType = null) {
            const apiKey = "AIzaSyAVWH17A-OPaAObl86DdfkiSkyFajnwZTw"; 
            const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-09-2025:generateContent?key=${apiKey}`;
            let prompt = "";
            let parts = [];
            if (previousBase64Data && previousMimeType) {
                prompt = "請你扮演一位專業的SOP撰寫專家。你的任務是嚴格比較兩張連續截圖，並僅輸出「從舊畫面到新畫面發生的單一操作動作」。請用簡潔的英文動詞片語（例如：「Click confirm button」, 「Enter username and password」）來描述單一操作動作。字數限制在 20 個單字內。如果動作不明顯或只是畫面移動，請回答「Scroll screen」或「No visible change」。";
                parts = [
                    { text: "這是「舊畫面」：" },
                    { inlineData: { mimeType: previousMimeType, data: previousBase64Data } },
                    { text: "這是「新畫面」：" },
                    { inlineData: { mimeType: mimeType, data: base64ImageData } },
                    { text: prompt }
                ];
            } else {
                prompt = "請你扮演一位專業的SOP撰寫專家。你的任務是描述這張截圖所展示的「操作起點」或「主要頁面」。請用簡潔的英文名詞片語（例如：「Home page dashboard」, 「Login screen」）來描述畫面內容。字數限制在 20 個單字內。";
                parts = [
                    { text: prompt },
                    { inlineData: { mimeType: mimeType, data: base64ImageData } }
                ];
            }
            const payload = {
                contents: [{ parts: parts }], 
                generationConfig: {
                    temperature: 0.1, 
                    maxOutputTokens: 1024 
                }
            };
            let response;
            let result;
            let retries = 3;
            let delay = 1000; 
            for (let i = 0; i < retries; i++) {
                try {
                    response = await fetch(apiUrl, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify(payload)
                    });
                    if (response.status === 429) { 
                        throw new Error('Rate limit exceeded (429)');
                    }
                    if (response.status === 403) {
                        console.error("API 請求被拒絕 (403 Forbidden)。");
                        throw new Error('API 請求被拒絕 (403)。請檢查 API 金鑰權限。');
                    }
                    if (!response.ok) {
                        throw new Error(`API 請求失敗: ${response.status} ${response.statusText}`);
                    }
                    result = await response.json();
                    if (result.candidates && 
                        result.candidates.length > 0 && 
                        result.candidates[0].content &&
                        result.candidates[0].content.parts &&
                        result.candidates[0].content.parts.length > 0 &&
                        result.candidates[0].content.parts[0].text) {
                        return result.candidates[0].content.parts[0].text; 
                    } else {
                        if (result.promptFeedback && result.promptFeedback.blockReason) {
                            console.error("AI 分析被封鎖:", result.promptFeedback.blockReason);
                            throw new Error(`AI 分析被封鎖: ${result.promptFeedback.blockReason}`);
                        }
                        if (result.candidates && result.candidates.length > 0 && 
                            (!result.candidates[0].content || !result.candidates[0].content.parts || result.candidates[0].content.parts.length === 0)) {
                             const finishReason = result.candidates[0].finishReason || '未知';
                            console.error("AI 回應為空，可能的原因:", finishReason);
                        }
                        console.error("無效的 API 回應結構:", JSON.stringify(result));
                        throw new Error('無效的 API 回應結構');
                    }
                } catch (err) {
                    console.warn(`AI 分析失敗 (嘗試 ${i + 1} / ${retries}):`, err.message);
                    if (i < retries - 1) {
                        await new Promise(resolve => setTimeout(resolve, delay));
                        delay *= 2; 
                    } else {
                        throw err;
                    }
                }
            }
        }

        async function processScreenshotsWithLLM() {
            if (screenshotCache.length === 0) {
                llmStatus.textContent = "沒有擷取任何螢幕畫面，無法產生註解。";
                llmStatus.hidden = false;
                return;
            }
            llmStatus.textContent = `偵測到 ${screenshotCache.length} 張截圖。正在準備呼叫 AI...`;
            llmStatus.hidden = false;
            insertFinalStepButton.hidden = true; 
            // 移除 pdfExportButton 的隱藏
            wordExportButton.hidden = true; 

            for (let i = 0; i < screenshotCache.length; i++) {
                const item = screenshotCache[i];
                if (item.status !== 'pending' || !item.imageDataUrl || item.imageDataUrl.includes('placeholder')) {
                     llmStatus.textContent = `AI 分析進度... (${i + 1} / ${screenshotCache.length}) - 步驟 ${i+1} 已跳過或為手動步驟`;
                    continue; 
                }
                try {
                    item.status = 'processing';
                    displayScreenshotsAndAnnotations(); 
                    const [header, base64Data] = item.imageDataUrl.split(',');
                    const mimeType = header.match(/:(.*?);/)[1];
                    let prevBase64Data = null;
                    let prevMimeType = null;
                    if (i > 0) {
                        const prevItem = screenshotCache[i - 1];
                        if (prevItem && prevItem.imageDataUrl && !prevItem.imageDataUrl.includes('placeholder')) {
                            const [prevHeader, prevData] = prevItem.imageDataUrl.split(',');
                            prevBase64Data = prevData;
                            prevMimeType = prevHeader.match(/:(.*?);/)[1];
                        }
                    }
                    const annotation = await callGeminiVision(base64Data, mimeType, prevBase64Data, prevMimeType);
                    item.annotation = annotation.trim();
                    item.status = 'success';
                } catch (err) {
                    console.error(`截圖 ${i + 1} 分析失敗:`, err);
                    const errorDetails = err.stack ? err.stack : err.message;
                    item.annotation = `AI 分析錯誤: ${errorDetails}`;
                    item.status = 'error';
                }
                displayScreenshotsAndAnnotations();
                llmStatus.textContent = `AI 分析進度... (${i + 1} / ${screenshotCache.length})`;
            }

            llmStatus.textContent = "AI 分析全部完成！報告已產生。您現在可以編輯步驟、移除、新增或替換圖片。";
            // 移除 pdfExportButton 的顯示
            wordExportButton.hidden = false; 
            insertFinalStepButton.hidden = false; 
        }

        // --- 互動功能: 註解編輯、圖片上傳、刪除步驟、插入空步驟 ---
        function handleAnnotationChange(index, newText) {
            if (screenshotCache[index]) {
                screenshotCache[index].annotation = newText;
            }
        }
        function handleImageUpload(index, file) {
            if (!file || !file.type.startsWith('image/')) {
                showError("請選擇一個有效的圖片檔案。");
                return;
            }
            const reader = new FileReader();
            reader.onload = (e) => {
                const newImageDataUrl = e.target.result;
                if (screenshotCache[index]) {
                    screenshotCache[index].imageDataUrl = newImageDataUrl;
                    screenshotCache[index].status = 'success'; 
                    displayScreenshotsAndAnnotations(); 
                    hideError(); 
                    setTimeout(() => {
                        const newItem = document.getElementById(`step-item-${index}`);
                        if (newItem) {
                            newItem.scrollIntoView({ behavior: 'smooth', block: 'start' });
                        }
                    }, 50);
                }
            };
            reader.onerror = (e) => {
                showError(`讀取檔案失敗: ${e.target.error.name}`);
            };
            reader.readAsDataURL(file);
        }
        function deleteScreenshot(index) {
            if (index >= 0 && index < screenshotCache.length) {
                if (confirm(`確定要移除步驟 ${index + 1} 嗎？此操作不可逆。`)) {
                    screenshotCache.splice(index, 1);
                    displayScreenshotsAndAnnotations();
                    if (screenshotCache.length === 0) {
                        resetUI(); 
                    }
                }
            }
        }
        function insertBlankStep(index) {
             const newStep = {
                imageDataUrl: 'https://placehold.co/600x400/D0E0FF/000000?text=Manual+Step',
                annotation: '請在這裡手動輸入操作步驟或說明。 (Manual step)',
                status: 'success' 
            };
            screenshotCache.splice(index + 1, 0, newStep);
            displayScreenshotsAndAnnotations();
            setTimeout(() => {
                const newIndex = index + 1;
                const newItem = document.getElementById(`step-item-${newIndex}`);
                if (newItem) {
                    newItem.scrollIntoView({ behavior: 'smooth', block: 'start' });
                }
            }, 100);
        }

        // --- 顯示截圖與註解的函式 ---
        function displayScreenshotsAndAnnotations() {
            screenshotsResultArea.innerHTML = ''; 
            let htmlContent = '<h2 class="text-2xl font-semibold text-gray-800 mb-6">AI 產生操作步驟 (可編輯)</h2>';
            screenshotCache.forEach((item, i) => {
                let annotationHtml = '';
                let actionButtons = '';
                if (item.status === 'pending') {
                    annotationHtml = '<p class="text-gray-500">等待分析...</p>';
                } else if (item.status === 'processing') {
                    annotationHtml = `
                        <div class="flex items-center gap-2 text-blue-600">
                            <div class="spinner"></div>
                            <span>AI 正在分析中...</span>
                        </div>`;
                } else if (item.status === 'success' || item.status === 'error') { 
                    const isError = item.status === 'error';
                    const textareaClasses = isError 
                        ? 'text-red-700 bg-red-50 border-red-300' 
                        : 'text-gray-700 bg-gray-50 border-gray-300';
                    annotationHtml = `
                        <textarea 
                            id="annotation-${i}"
                            class="w-full ${textareaClasses} p-4 rounded-md border focus:ring-blue-500 focus:border-blue-500 resize-y"
                            rows="3"
                            onchange="handleAnnotationChange(${i}, this.value)"
                        >${item.annotation}</textarea>
                    `;
                    actionButtons = `
                        <div class="action-buttons mt-4 flex flex-wrap gap-2 justify-end">
                            <button onclick="insertBlankStep(${i})" class="px-3 py-1 text-sm bg-blue-500 text-white rounded-md hover:bg-blue-600 transition-colors shadow-sm">
                                插入空步驟 (後)
                            </button>
                            <button onclick="deleteScreenshot(${i})" class="px-3 py-1 text-sm bg-red-500 text-white rounded-md hover:bg-red-600 transition-colors shadow-sm">
                                移除此步驟
                            </button>
                        </div>
                    `;
                }
                htmlContent += `
                    <div class="screenshot-item mb-8 p-4 border border-gray-200 rounded-lg shadow-md" id="step-item-${i}">
                        <h3 class="text-lg font-semibold text-gray-700 mb-3">步驟 ${i + 1}</h3>
                        <img src="${item.imageDataUrl}" class="w-full h-auto rounded-md shadow-sm mb-4 border">
                        <div class="mb-4 image-upload-area">
                            <label for="file-upload-${i}" class="block text-sm font-medium text-gray-700 mb-2">
                                替換步驟 ${i + 1} 的圖片 (選用):
                            </label>
                            <input type="file" id="file-upload-${i}" 
                                   accept="image/*" 
                                   class="block w-full text-sm text-gray-500
                                          file:mr-4 file:py-2 file:px-4
                                          file:rounded-full file:border-0
                                          file:text-sm file:font-semibold
                                          file:bg-violet-50 file:text-violet-700
                                          hover:file:bg-violet-100 cursor-pointer"
                                   onchange="handleImageUpload(${i}, this.files[0])">
                        </div>
                        <h4 class="text-md font-semibold text-blue-700 mb-2 print-only-label">AI 註解:</h4>
                        ${annotationHtml}
                        ${actionButtons}
                    </div>
                `;
            });
            screenshotsResultArea.innerHTML = htmlContent;
            
            if (screenshotCache.length > 0) {
                // 移除 pdfExportButton 的顯示
                wordExportButton.hidden = false; 
                insertFinalStepButton.hidden = false;
            } else {
                // 移除 pdfExportButton 的隱藏
                wordExportButton.hidden = true; 
                insertFinalStepButton.hidden = true;
            }
        }


        // --- 產生 Word/PDF 共用 HTML 的函式 (未修改，但現在只被 Word 匯出使用) ---
        async function generateExportHtml(title, cache) {
            let stepsHtml = '';
            
            // 迴圈處理每一步驟
            for (let i = 0; i < cache.length; i++) {
                const item = cache[i];
                
                // 壓縮圖片 (確保 Word/PDF 不會爆框)
                // 設置最大寬度為 750px
                const compressedImage = await resizeImage(item.imageDataUrl, 750); 
                
                stepsHtml += `
                    <div style="margin-bottom: 25px; page-break-inside: avoid; text-align: center;">
                        <h3 style="font-size: 16pt; font-weight: bold; color: #1F2937; margin-bottom: 10px; text-align: left;">步驟 ${i + 1}</h3>
                        
                        <!-- 圖片使用壓縮後的 Base64 資料 -->
                        <img src="${compressedImage}" 
                             style="width: 100%; max-width: 750px; height: auto; display: block; margin: 0 auto 15px auto; border: 1px solid #ccc;">
                        
                        <h4 style="font-size: 12pt; font-weight: bold; color: #3B82F6; margin-top: 15px; margin-bottom: 5px; text-align: left;">操作註解:</h4>
                        
                        <p style="font-size: 11pt; color: #4B5563; padding: 10px; border: 1px solid #E5E7EB; border-radius: 4px; background-color: #F9FAFB; text-align: left; white-space: pre-wrap; word-wrap: break-word;">
                            ${item.annotation ? item.annotation.replace(/\n/g, '<br>') : '無註解'}
                        </p>
                    </div>
                    <!-- 每個步驟後嘗試強制分頁 (對 Word 提示作用) -->
                    <div style="page-break-after: always;"></div> 
                `;
            }
            
            // 2. 完整的 HTML 結構
            const htmlContent = `
                <!DOCTYPE html>
                <html lang="zh-Hant">
                <head>
                    <meta charset="UTF-8">
                    <title>${title}</title>
                    <style>
                        body {
                            font-family: 'Inter', 'Microsoft JhengHei', sans-serif;
                            padding: 50px;
                            line-height: 1.6;
                        }
                        .document-title {
                            font-size: 24pt;
                            font-weight: 700;
                            text-align: center;
                            margin-bottom: 40px;
                            color: #111827;
                        }
                        /* 設置圖片的最大容器寬度，與 resizeImage 中的 750px 保持一致 */
                        img {
                            max-width: 750px !important; 
                        }
                    </style>
                </head>
                <body>
                    <h1 class="document-title">${title}</h1>
                    <div class="step-list">
                        ${stepsHtml}
                    </div>
                </body>
                </html>
            `;
            return htmlContent;
        }


        // --- (保留) 匯出 Word (.doc) 函式 ---
        async function exportToWord() {
            if (screenshotCache.length === 0) {
                 showError("沒有可匯出的內容。");
                 return;
            }
            
            llmStatus.textContent = '正在產生 Word 檔案...';
            llmStatus.hidden = false;
            
            try {
                const title = documentTitleInput.value || '自動化 SOP 報告';
                
                // 1. 取得共用的 HTML 內容
                const htmlContent = await generateExportHtml(title, screenshotCache);
                
                // 2. 使用 Blob 和 FileSaver 儲存為 .doc
                const blob = new Blob([htmlContent], {
                    type: 'application/msword;charset=utf-8' 
                });
                
                const safeTitle = title.replace(/[\\/:"*?<>|]/g, '_'); 
                const fileName = `${safeTitle}-${new Date().toISOString().substring(0, 10)}.doc`;
                saveAs(blob, fileName);
                
                llmStatus.textContent = 'Word 檔案已成功匯出！';
            
            } catch (err) {
                console.error("Word 產生失敗:", err);
                showError("Word 產生失敗: " + err.message);
                llmStatus.textContent = '匯出 Word 失敗。';
            }
        }

        // --- 移除 exportToPDF 函式 ---


        // --- 綁定事件 ---
        // 移除 pdfExportButton.addEventListener('click', exportToPDF);
        wordExportButton.addEventListener('click', exportToWord);

    </script>
</body>
</html>